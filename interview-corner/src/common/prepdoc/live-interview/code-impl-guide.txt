¬†configure ms for https
--------------------------
1. Generate an SSL Certificate
For local development, you can use a self-signed certificate with keytool:

keytool -genkeypair -alias my-https-cert \
  -keyalg RSA -keysize 2048 -storetype PKCS12 \
  -keystore my-https-cert.p12 -validity 3650
It will ask for:

Keystore password (remember this)
Your name, org, location, etc.

This creates my-https-cert.p12 in the current folder.

2. Put the Keystore in Your Project
Move my-https-cert.p12 to:

src/main/resources/
3. Configure Spring Boot for HTTPS
Edit your application.properties or application.yml:

application.properties

server.port=8443
server.ssl.key-store=classpath:my-https-cert.p12
server.ssl.key-store-password=your_password_here
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=my-https-cert

5. For Production (Real HTTPS)
Get a CA-signed certificate (e.g., Let‚Äôs Encrypt).

Replace the .p12 file with your real certificate.

Update application.properties with the new certificate path and password.

Configure reverse proxy (Nginx, Apache) if you need load balancing + HTTPS termination.limiter

impl circut breaker
-------------------------
 1. Add Dependencies
If you're using Maven, add this to your pom.xml:

<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
For Spring Boot 3+, use: resilience4j-spring-boot3

üßæ 2. Configure Circuit Breaker
Add to your application.yml:


resilience4j:
  circuitbreaker:
    instances:
      myService:
        registerHealthIndicator: true
        slidingWindowSize: 10
        permittedNumberOfCallsInHalfOpenState: 3
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
üßë‚Äçüíª 3. Annotate Your Method
Use @CircuitBreaker on the method you want to protect.

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.stereotype.Service;

@Service
public class MyService {

    @CircuitBreaker(name = "myService", fallbackMethod = "fallback")
    public String callExternalService() {
        // simulate external call
        if (Math.random() > 0.5) {
            throw new RuntimeException("Service failed");
        }
        return "Success from external service";
    }

    public String fallback(Throwable t) {
        return "Fallback response due to error: " + t.getMessage();
    }
}

================================================================================================================================================================================================================
multi-factor authentication

Implementing Multi-Factor Authentication (MFA) in Java typically involves two main steps:
Primary Authentication ‚Äî usually with username/password.
Secondary Authentication ‚Äî typically via:
OTP (One-Time Password) via SMS/email/app (like Google Authenticator)
Hardware tokens (less common in small apps)

We'll walk through a simple MFA implementation using:

Spring Boot
TOTP (Time-Based One-Time Password) for the second factor
Google Authenticator or similar app for OTP validation

 Step-by-Step: MFA with Java (Spring Boot + TOTP)
üì¶ 1. Add Dependencies
In pom.xml (for Spring Boot + OTP support):

<dependencies>
    <!-- Spring Boot Web and Security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- For TOTP generation/verification -->
    <dependency>
        <groupId>com.warrenstrange</groupId>
        <artifactId>googleauth</artifactId>
        <version>1.6.0</version>
    </dependency>
</dependencies>
üß† 2. How TOTP Works
Generate a secret key and show it as a QR code to the user.
User adds it to Google Authenticator.
On login, after password is verified, prompt for 6-digit OTP.
Validate the OTP using the secret.

üßë‚Äçüíª 3. Java Service for TOTP (Google Authenticator)
import com.warrenstrange.googleauth.GoogleAuthenticator;
import com.warrenstrange.googleauth.GoogleAuthenticatorKey;
import com.warrenstrange.googleauth.GoogleAuthenticatorQRGenerator;
import org.springframework.stereotype.Service;

@Service
public class TOTPService {
    private final GoogleAuthenticator gAuth = new GoogleAuthenticator();

    public String createSecretKey() {
        GoogleAuthenticatorKey key = gAuth.createCredentials();
        return key.getKey();
    }

    public String getQRCode(String user, String secret) {
        return GoogleAuthenticatorQRGenerator.getOtpAuthURL("MyApp", user, secret);
    }

    public boolean verifyCode(String secret, int code) {
        return gAuth.authorize(secret, code);
    }
}
üéØ 4. Sample Flow
Registration

User signs up.
You generate a TOTP secret and show QR code.
User scans it using Google Authenticator.
Save the secret in DB tied to the user.

Login Flow

User logs in with username/password.
If correct, ask for 6-digit code.
Verify the TOTP using the secret.

üñºÔ∏è 5. Generate QR Code (Optional)
Use Google Charts API:

String qrUrl = "https://chart.googleapis.com/chart?chs=200x200&cht=qr&chl=" + URLEncoder.encode(authUrl, "UTF-8");
You can return this image URL to the frontend or render it in a QRCode library in Java.

‚úÖ 6. SecurityController (Simplified Example)

@RestController
@RequestMapping("/auth")
public class AuthController {

    @Autowired
    private TOTPService totpService;

    private Map<String, String> userSecrets = new HashMap<>(); // simulate DB

    @PostMapping("/register")
    public String register(@RequestParam String username) {
        String secret = totpService.createSecretKey();
        userSecrets.put(username, secret);
        return totpService.getQRCode(username, secret);
    }

    @PostMapping("/login")
    public String login(@RequestParam String username, @RequestParam int code) {
        String secret = userSecrets.get(username);
        if (secret == null) return "User not found";

        if (totpService.verifyCode(secret, code)) {
            return "Login successful!";
        } else {
            return "Invalid TOTP code";
        }
    }
}

================================================================================================================================================================================================================
 zipkin implentation microservices
 
 1. Add Dependencies
For each microservice, include the following dependencies in your pom.xml (for Maven):

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
Also add the Spring Cloud BOM in your dependencyManagement section:

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>your-spring-cloud-version</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
Use a compatible Spring Cloud version like Hoxton, 2020.x, or 2021.x depending on your Spring Boot version.

‚úÖ 2. Configure Zipkin in application.yml or application.properties

spring:
  application:
    name: your-microservice-name
  zipkin:
    base-url: http://localhost:9411  # URL where Zipkin server is running
    sender:
      type: web
  sleuth:
    sampler:
      probability: 1.0  # Sends 100% of traces (use lower value in production)
Or in application.properties:


spring.application.name=your-microservice-name
spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0
‚úÖ 3. Run Zipkin Server
You can run the Zipkin server in several ways:

Option 1: Docker

docker run -d -p 9411:9411 openzipkin/zipkin
Option 2: Java (if you prefer JAR)
Download from Zipkin GitHub Releases and run:


java -jar zipkin-server-*.jar
‚úÖ 4. Add HTTP Call Tracing
If your services use RestTemplate or WebClient, Sleuth will automatically instrument them. But you can add custom spans for more control:

With RestTemplate

@Autowired
private RestTemplate restTemplate;

// Already auto-instrumented by Sleuth
With WebClient
@Bean
public WebClient.Builder webClientBuilder() {
    return WebClient.builder();
}


=========================================================================================================================================================================================================================
implement radis cache
--------------------
1. Redis Cluster Setup (for Production)
Use Redis Cluster for high availability. For dev/local testing, a single Redis instance via Docker is often enough
docker run -d -p 6379:6379 --name redis redis

2. Microservices Architecture Example
[ API Gateway ]
      |
-----------------------
|  User Service       |
|  Product Service    |
|  Order Service      |
-----------------------
       |
  [ Redis Cluster ]

3. Add Redis to a Spring Boot Microservice
a. Add Dependencies (pom.xml)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
yml file
spring:
  redis:
    host: localhost
    port: 6379
    timeout: 6000
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 2
		
		spring:
		
		For cluster:yml file
  redis:
    cluster:
      nodes:
        - 127.0.0.1:7000
        - 127.0.0.1:7001
        - 127.0.0.1:7002
		
c. Configure Redis in Service

@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(60))
            .disableCachingNullValues();

        return RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
    }
}

4. Caching in Your Service Layer
@Service
public class UserService {

    @Cacheable(value = "users", key = "#userId")
    public User getUser(String userId) {
        System.out.println("Fetching user from DB...");
        return userRepository.findById(userId).orElse(null);
    }

    @CachePut(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }

    @CacheEvict(value = "users", key = "#userId")
    public void deleteUser(String userId) {
        userRepository.deleteById(userId);
    }
}

3.how to Authorized role based in microservices
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://localhost:8080/realms/myrealm/protocol/openid-connect/certs
		  
		  @EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt()); // JWT-based auth
        return http.build();
    }
}

@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
    converter.setAuthoritiesClaimName("roles");
    converter.setAuthorityPrefix("ROLE_");

    JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
    authConverter.setJwtGrantedAuthoritiesConverter(converter);
    return authConverter;
}

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(authz -> authz
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(oauth2 -> oauth2
            .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter())));
    return http.build();
}



------------------
Method-Level Authorization in Microservices (Spring Boot)

1. Enable Method Security
In your config class (e.g., SecurityConfig.java), enable method-level security:

@EnableMethodSecurity(prePostEnabled = true)  // Spring Security 6+
@Configuration
public class SecurityConfig {
    // Your JWT configuration here
}
For Spring Boot 2.x use: @EnableGlobalMethodSecurity(prePostEnabled = true)

2. Use Role-Based Annotations on Methods
You can now use:

‚úÖ @PreAuthorize Example

@Service
public class OrderService {

    @PreAuthorize("hasRole('ADMIN')")
    public void deleteOrder(Long orderId) {
        // Only ADMIN can delete
    }

    @PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    public Order getOrder(Long orderId) {
        // Both USER and ADMIN can view
    }
}
‚úÖ @Secured Example

@Secured("ROLE_ADMIN")
public void performAdminTask() {
    // Only ADMIN
}
Note: @Secured is simpler but supports only roles, not SpEL expressions.

3. Customizing Role Claim in JWT (if needed)
If your JWT token uses roles claim instead of authorities, use this converter:

@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
    converter.setAuthoritiesClaimName("roles"); // or "authorities" based on token
    converter.setAuthorityPrefix("ROLE_");      // Prefix needed for hasRole()

    JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
    authConverter.setJwtGrantedAuthoritiesConverter(converter);
    return authConverter;
}

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
        .oauth2ResourceServer(oauth2 -> oauth2
            .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter())));
    return http.build();
}
üß™ Example: Microservice Method Security
Controller

@RestController
@RequestMapping("/product")
public class ProductController {

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping("/create")
    public ResponseEntity<?> createProduct(@RequestBody Product product) {
        return ResponseEntity.ok("Product Created");
    }

    @PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    @GetMapping("/{id}")
    public ResponseEntity<?> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok("Product details");
    }
}


java 17 new features
1. Sealed Classes (Finalized)
Limit which classes can extend or implement a class/interface.

public sealed class Animal permits Dog, Cat {}

public final class Dog extends Animal {}
public final class Cat extends Animal {}
Use case: Finite and controlled inheritance.

Improves type safety and exhaustive pattern matching.

2. Pattern Matching for instanceof (Finalized)
Simplifies casting after instanceof.

if (obj instanceof String s) {
    System.out.println(s.toLowerCase());
}
Cleaner, safer, and avoids manual casting.

3. Switch Expressions (Previewed earlier, stable in Java 14)
Still relevant: concise switch statements.


int result = switch (day) {
    case MONDAY, FRIDAY -> 6;
    case TUESDAY -> 7;
    default -> throw new IllegalArgumentException("Invalid day");
};
4. New record Class (Introduced in Java 14, stable in 16)
Lightweight data carriers with minimal boilerplate.

public record Person(String name, int age) {}
Auto-generates constructor, equals(), hashCode(), and toString().

5. Text Blocks (Finalized)
Multi-line string literals with clean formatting.

String html = """
    <html>
        <body>
            Hello, Java 17!
        </body>
    </html>
    """;
Better readability for JSON, SQL, HTML, etc.

6. JEP 356: Enhanced Pseudo-Random Number Generators
New API for random number generation with more flexibility.

RandomGenerator generator = RandomGenerator.of("L64X128MixRandom");
int randomInt = generator.nextInt();
Useful for simulations, games, and testing.

====================================================================================================================
how many wasy call ms from another ms
1. HTTP/REST API Call
ebClient webClient = WebClient.create("http://service-b");

Mono<String> response = webClient.get()
    .uri("/api/data")
    .retrieve()
    .bodyToMono(String.class);

response.subscribe(System.out::println);

Using Spring RestTemplate (Blocking)
RestTemplate restTemplate = new RestTemplate();
String response = restTemplate.getForObject("http://service-b/api/data", String.class);
System.out.println(response);

2. gRPC Call
ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 50051)
    .usePlaintext()
    .build();

MyServiceGrpc.MyServiceBlockingStub stub = MyServiceGrpc.newBlockingStub(channel);

MyRequest request = MyRequest.newBuilder()
    .setParam("value")
    .build();

MyResponse response = stub.myMethod(request);

Message Broker (RabbitMQ)
@Autowired
private RabbitTemplate rabbitTemplate;

public void sendMessage() {
    String message = "{\"event\": \"user_created\", \"data\": {\"id\": 123}}";
    rabbitTemplate.convertAndSend("service-b-queue", message);
}

4. Kafka Producer
@Autowired
private KafkaTemplate<String, String> kafkaTemplate;

public void sendEvent() {
    kafkaTemplate.send("user-events", "{\"userId\":123}");
}

5. Feign Client (HTTP - Declarative)
@FeignClient(name = "service-b", url = "http://service-b")
public interface ServiceBClient {
    @GetMapping("/api/data")
    String getData();
}

// Usage
@Autowired
private ServiceBClient serviceBClient;

public void callServiceB() {
    String data = serviceBClient.getData();
    System.out.println(data);
}

6. Service Discovery (Eureka + Ribbon or Kubernetes)
String response = restTemplate.getForObject("http://service-b/api/data", String.class);

GraphQL (Optional)
String query = "{ user(id: \"123\") { name email } }";
String response = restTemplate.postForObject("http://service-b/graphql", query, String.class);

===========================================================================
When you have multiple implementations of an interface in Spring and want to inject one of them, Spring cannot determine which one to use automatically, so you need to help it choose.

1. Use @Qualifier Annotation
public interface PaymentService {
    void pay();
}
Two implementations:

@Service("paypalService")
public class PaypalService implements PaymentService {
    public void pay() {
        System.out.println("Paid with PayPal");
    }
}

@Service("stripeService")
public class StripeService implements PaymentService {
    public void pay() {
        System.out.println("Paid with Stripe");
    }
}
Inject using:

@Autowired
@Qualifier("paypalService") // or "stripeService"
private PaymentService paymentService;

2. Use @Primary Annotation (Default Implementation)
Service
@Primary
public class PaypalService implements PaymentService {
    public void pay() {
        System.out.println("Paid with PayPal");
    }
}
Then you can just use:

@Autowired
private PaymentService paymentService; // will inject PaypalService

3. Inject All Implementations as a Map or List
@Autowired
private List<PaymentService> paymentServices;

or

@Autowired
private Map<String, PaymentService> paymentServiceMap;
Then Spring will inject a Map with keys as the bean names ("paypalService", "stripeService") and values as the instances.

Example:

paymentServiceMap.get("paypalService").pay();

 4. Custom Configuration (Advanced)
 
 @Configuration
public class PaymentConfig {
    
    @Bean("paypal")

@Autowired
@Qualifier("paypal")
private PaymentService paymentService;

how to open our service for fixed no of services/ip whitelisting/whitelisting upstream ms
=========================================================================================================================================
 Option 1: Mutual TLS (mTLS)
 ================
Use X.509 certificates to verify the identity of each client.

‚úÖ Benefits:
Cryptographically secure
Doesn‚Äôt need tokens or extra requests
Enforces access based on client identity (CN, OU, etc.)

üß± Implementation Steps:
‚úÖ Generate a unique certificate for each service
‚úÖ Your server validates client certificates
‚úÖ Restrict access only to specific certificate identities

üöÄ How to Restrict Access:

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/**").access(this::clientAccessCheck)
                .anyRequest().denyAll())
            .x509(x509 -> x509
                .subjectPrincipalRegex("CN=(.*?)(?:,|$)")
                .userDetailsService(username -> new User(username, "", List.of()))
            );
        return http.build();
    }

    private AuthorizationDecision clientAccessCheck(Authentication auth, HttpServletRequest request) {
        String clientCN = auth.getName();
        List<String> allowedClients = List.of("service-a", "service-b", "gateway"); // allowed CNs
        return new AuthorizationDecision(allowedClients.contains(clientCN));
    }
}


Option 2: JWT Tokens with Service Whitelisting
==============
Services send JWT tokens signed with a shared key (or via OAuth2 server). Your service verifies:

Signature
Expiry
Issuer
AND sub or aud claims against a whitelist
‚úÖ Benefits:
Easier to rotate/renew credentials
No SSL cert generation required
Easier in containerized/cloud-native environments
üöÄ JWT Claim Whitelisting Example:
public class JwtAuthFilter extends OncePerRequestFilter {

    private static final List<String> allowedServices = List.of("service-a", "service-b");

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        String token = resolveToken(request);
        if (token != null && validateToken(token)) {
            Claims claims = parseToken(token);
            String serviceName = claims.getSubject(); // or claims.get("client_id")

            if (!allowedServices.contains(serviceName)) {
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                return;
            }

            // Set auth context
            SecurityContextHolder.getContext().setAuthentication(
                new UsernamePasswordAuthenticationToken(serviceName, null, List.of())
            );
        }

        chain.doFilter(request, response);
    }
}


how diffrent wasy to handle transaction in ms/2PC and Saga(for less time)
================================================================================================================================================
‚úÖ 1. Local Transactions
Use local database transactions within a single microservice.
Handled via traditional ACID-compliant transactions (e.g., using JPA/Hibernate in Java).
Limit: Only works within one service boundary.

‚úÖ 2. Distributed Transactions (2PC - Two Phase Commit)
Coordinates a transaction across multiple services/databases.
Uses a transaction coordinator (e.g., JTA/XA).
Limitations:
Complex and hard to scale.
Tight coupling between services.
Poor fault tolerance.

‚úÖ 3. Saga Pattern (Most Common)
Manages long-running, distributed transactions via a series of local transactions and compensating actions.
üîπ Types of Saga:
Choreography-based Saga:
Services emit events and listen for events from others.

No centralized orchestrator.
Lightweight but harder to manage for large workflows.
Orchestration-based Saga:
A centralized orchestrator directs all participants.
Easier to track and debug.
Central coordination logic.

‚úÖ 4. Eventual Consistency with Event Sourcing
Uses event sourcing and eventual consistency instead of immediate consistency.
Stores state changes as a sequence of events.
Services react to events asynchronously.
Often paired with CQRS (Command Query Responsibility Segregation).

‚úÖ 5. Transactional Outbox Pattern
Writes domain event to a local ‚Äúoutbox‚Äù table in the same DB transaction.
A background process publishes these events to a message broker (Kafka, RabbitMQ).
Ensures event publishing is part of the local transaction.

‚úÖ 6. Change Data Capture (CDC)
Monitors DB changes and publishes events (e.g., using Debezium).
Used in conjunction with Transactional Outbox or alone.
Useful for keeping read models in sync.

‚úÖ 7. Compensation and Retry Mechanisms
If a step fails, previous successful steps are compensated (undone).
Implement retry strategies (exponential backoff, circuit breakers).

‚úÖ 8. Idempotency Handling
Ensures that retrying an operation doesn‚Äôt produce duplicate results.
Important for APIs and event processing in distributed systems.


Details about GC java 17 and how internall it works
===============================================================================================================================
Young Generation

New objects are allocated here.
Frequent GC (called Minor GC).

Divided into:

Eden (where new objects go)
Survivor spaces (S0, S1)

Objects that survive multiple collections get promoted to:

Old Generation (Tenured)
Stores long-lived objects.
Less frequent GC (called Major or Full GC).

(Optional) Metaspace: Stores class metadata, not managed by traditional heap GC.

üîÑ GC Lifecycle:
New object ‚Üí Eden.
Minor GC occurs ‚Üí survivors move to S0/S1.
After N survivals ‚Üí promote to Old Gen.
If Old Gen fills ‚Üí Major GC occurs (slower).

GC Algorithms in Java 17
GC Algorithm	Description	When to Use
Serial GC	Single-threaded, stop-the-world. Simple and compact.	Best for small heaps, single-core machines.
Parallel GC	Multi-threaded, throughput-focused.	Good default for large batch-processing apps.
G1 GC (Default)	Splits heap into regions; concurrent + incremental compaction.	Balanced latency and throughput. Default in Java 9+.
ZGC	Ultra-low pause time GC. Most of the work is done concurrently.	Large heap applications needing low latency.
Shenandoah GC	Similar to ZGC; low-pause, concurrent compaction.	Also for low-latency apps with big heaps.
Epsilon GC	No GC. Only allocates memory. For testing/performance tuning.

Why kafka when and where use in java/ms
===================================================================================
Why Kafka?
Feature	Why It Matters
High throughput	Can handle millions of messages per second.
Durability	Messages are stored on disk, with configurable retention.
Scalability	Horizontally scalable via partitions and brokers.
Fault tolerance	Replicated data across brokers, survives failures.
Decoupling services	Producers and consumers are loosely coupled.
Replayable logs	Consumers can reprocess messages anytime.
Event-driven	Promotes reactive, decoupled systems.

 When to Use Kafka in Java/Microservices
üîπ 1. Event-Driven Architecture
Publish events like OrderPlaced, UserSignedUp, etc.
Multiple services can subscribe and react.

// Producer
kafkaTemplate.send("user-signup", new UserEvent(...));
üîπ 2. Asynchronous Communication
Avoid synchronous REST calls between services.
Better fault isolation and loose coupling.

üîπ 3. Audit Logs / Activity Tracking
Record every change/event (like logs, metrics).
üîπ 4. Data Ingestion Pipelines
Stream data from various sources (IoT, logs, databases).
üîπ 5. Stream Processing
Real-time analytics using Kafka Streams, Flink, etc.
üîπ 6. CQRS / Event Sourcing
Commands trigger events stored in Kafka.
Query models built by listening to event streams.

kafka implentation between two ms complete java code implemntation
-------------------------------------------------------------------------
‚úÖ Scenario:
Service A (Producer): Sends a message when a user signs up.

Service B (Consumer): Listens to the Kafka topic and logs the event.

üß± Technologies:
Spring Boot

Spring Kafka

Apache Kafka (running locally or Docker)

üêò Kafka Setup (Docker Compose)
If Kafka is not yet running, use this in docker-compose.yml:

version: '3'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  kafka:
    image: confluentinc/cp-kafka:latest
    ports:
      - "9092:9092"
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
Start with:

docker-compose up -d
üß© 1. Service A ‚Äì Kafka Producer
üõ†Ô∏è Create Spring Boot Project (user-service)
pom.xml

<dependencies>
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
application.yml

spring:
  kafka:
    bootstrap-servers: localhost:9092
UserEvent.java

public class UserEvent {
    private String userId;
    private String email;

    // getters and setters
}
KafkaProducerConfig.java
@Configuration
public class KafkaProducerConfig {

    @Bean
    public ProducerFactory<String, UserEvent> producerFactory() {
        Map<String, Object> config = new HashMap<>();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(config);
    }

    @Bean
    public KafkaTemplate<String, UserEvent> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}
UserController.java
@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private KafkaTemplate<String, UserEvent> kafkaTemplate;

    private static final String TOPIC = "user-signup-topic";

    @PostMapping
    public ResponseEntity<String> registerUser(@RequestBody UserEvent userEvent) {
        kafkaTemplate.send(TOPIC, userEvent);
        return ResponseEntity.ok("User registered and event sent!");
    }
}
üß© 2. Service B ‚Äì Kafka Consumer
üõ†Ô∏è Create Spring Boot Project (notification-service)
pom.xml
Same as above, but also:
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
application.yml

spring:
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: notification-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: '*'
UserEvent.java
Same class as in Producer (userId, email).

KafkaConsumerConfig.java
@Configuration
public class KafkaConsumerConfig {

    @Bean
    public ConsumerFactory<String, UserEvent> consumerFactory() {
        Map<String, Object> config = new HashMap<>();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ConsumerConfig.GROUP_ID_CONFIG, "notification-group");
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        config.put(JsonDeserializer.TRUSTED_PACKAGES, "*");

        return new DefaultKafkaConsumerFactory<>(config, new StringDeserializer(), new JsonDeserializer<>(UserEvent.class));
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, UserEvent> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, UserEvent> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }
}
NotificationListener.java
@Service
public class NotificationListener {

    @KafkaListener(topics = "user-signup-topic", groupId = "notification-group")
    public void consume(UserEvent userEvent) {
        System.out.println("üì® Received User Signup Event: " + userEvent.getUserId() + ", " + userEvent.getEmail());
    }
}


how https in microservice steps by steps ms java
============================================================================
Step 1: Generate Self-Signed Certificate
Step 2: Move Keystore to src/main/resources/
Step 3: Configure HTTPS in application.yml
server:
  port: 8443
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: changeit
    key-store-type: PKCS12
    key-alias: mysslkey

implements auth2	
===============================================================
+-------------+       (Access Token)       +----------------+
|   Client    |  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  |  Service A     |
| (Frontend)  |                            |  (API Gateway) |
+-------------+                            +----------------+
                                                ‚îÇ
                                                ‚ñº
                                        [OAuth2 Authorization Server]
                                                ‚îÇ
                             Calls secured MSs using access token
							 
							 +----------------+  ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Auth Token ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  +----------------+
|  Service A     |                                     |  Service B      |
| (Resource API) |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [Token Forwarding] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂|  (Downstream)   |
+----------------+                                     +----------------+

1Ô∏è‚É£ Set Up OAuth2 Authorization Server
Use Spring Authorization Server or Keycloak (production ready)

Option 1: Spring Authorization Server (lightweight)
xml
<!-- pom.xml -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
</dependency>
// @Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
    // define clients, token store, authentication manager
}
Or use Keycloak if you want a ready-made tool.

2Ô∏è‚É£ Microservice A ‚Äî Authenticated API
application.yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:9000  # Your auth server
SecurityConfig.java
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        return http.build();
    }
}
3Ô∏è‚É£ Microservice A ‚Üí Call Microservice B
Use OAuth2RestTemplate or WebClient with token propagation.

Example: Forward token with WebClient

@Bean
public WebClient webClient(ReactiveOAuth2AuthorizedClientManager manager) {
    ServerOAuth2AuthorizedClientExchangeFilterFunction oauth =
        new ServerOAuth2AuthorizedClientExchangeFilterFunction(manager);
    oauth.setDefaultOAuth2AuthorizedClient(true);
    return WebClient.builder()
        .filter(oauth)
        .build();
}
Then in controller:

@Autowired
private WebClient webClient;

@GetMapping("/forward")
public Mono<String> callServiceB() {
    return webClient.get()
        .uri("http://service-b:8082/secure-endpoint")
        .retrieve()
        .bodyToMono(String.class);
}
4Ô∏è‚É£ Microservice B ‚Äî Protected by OAuth2 Token
Same as Microservice A:

Configure Spring Security with resource server

Token validation by issuer URI

application.yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:9000  # Same auth server
SecurityConfig.java

@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        return http.build();
    }
}


3.how to Authorized role based in microservices
===================================================================

JWT token should have a roles claim like:
{
  "sub": "john",
  "roles": ["ROLE_ADMIN", "ROLE_USER"]
}

application.yml

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:9000  
		  
		  @EnableWebSecurity
		  
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());

        return http.build();
    }
}

@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter authoritiesConverter = new JwtGrantedAuthoritiesConverter();
    authoritiesConverter.setAuthorityPrefix("ROLE_");
    authoritiesConverter.setAuthoritiesClaimName("roles");

    JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
    converter.setJwtGrantedAuthoritiesConverter(authoritiesConverter);
    return converter;
}
Use it in your resource server config:
.oauth2ResourceServer(oauth2 -> oauth2
    .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
);

@RestController
@RequestMapping("/admin")
public class AdminController {

    @GetMapping("/dashboard")
    public String adminOnly() {
        return "Welcome Admin!";
    }
}

@RestController
@RequestMapping("/user")
public class UserController {

    @GetMapping("/profile")
    public String userOnly() {
        return "Welcome User!";
    }
}

how to manag mathod level love base authentication
To manage method-level role-based authentication in Spring Boot microservices, you use Spring Security‚Äôs @PreAuthorize or @Secured annotations to restrict access based on roles from JWT tokens.

@EnableMethodSecurity  // replaces @EnableGlobalMethodSecurity in Spring Security 6+
public class SecurityConfig {
    ...
}

@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthoritiesClaimName("roles");
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_"); // required

    JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
    converter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return converter;
}

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(oauth -> oauth
            .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
        );

    return http.build();
}

@RestController
@RequestMapping("/admin")
public class AdminController {

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/dashboard")
    public String adminOnly() {
        return "Welcome Admin";
    }

    @PreAuthorize("hasAnyRole('ADMIN', 'USER')")
    @GetMapping("/shared")
    public String sharedAccess() {
        return "Welcome Admin or User";
    }
}

===================================================================================================================================
Step-by-Step Implementation (Simulated 2PC)
üìå 1. TransactionCoordinatorService (acts as 2PC Manager)

@RestController
@RequestMapping("/transaction")
public class TransactionCoordinatorController {

    private final RestTemplate restTemplate = new RestTemplate();

    @PostMapping("/process")
    public ResponseEntity<String> processTransaction() {
        String orderService = "http://localhost:8081/order";
        String paymentService = "http://localhost:8082/payment";

        try {
            // Phase 1: Prepare
            ResponseEntity<String> orderPrepare = restTemplate.postForEntity(orderService + "/prepare", null, String.class);
            ResponseEntity<String> paymentPrepare = restTemplate.postForEntity(paymentService + "/prepare", null, String.class);

            if (!orderPrepare.getBody().equals("OK") || !paymentPrepare.getBody().equals("OK")) {
                throw new RuntimeException("Prepare failed");
            }

            // Phase 2: Commit
            restTemplate.postForEntity(orderService + "/commit", null, String.class);
            restTemplate.postForEntity(paymentService + "/commit", null, String.class);

            return ResponseEntity.ok("Transaction committed");
        } catch (Exception e) {
            // Rollback if any service fails
            restTemplate.postForEntity(orderService + "/rollback", null, String.class);
            restTemplate.postForEntity(paymentService + "/rollback", null, String.class);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Transaction rolled back");
        }
    }
}
üìå 2. OrderService

@RestController
@RequestMapping("/order")
public class OrderController {

    private boolean prepared = false;

    @PostMapping("/prepare")
    public ResponseEntity<String> prepare() {
        // Simulate DB lock and staging
        prepared = true;
        System.out.println("Order Prepared");
        return ResponseEntity.ok("OK");
    }

    @PostMapping("/commit")
    public ResponseEntity<String> commit() {
        if (prepared) {
            System.out.println("Order Committed");
            // Persist changes
            prepared = false;
            return ResponseEntity.ok("Committed");
        }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Not prepared");
    }

    @PostMapping("/rollback")
    public ResponseEntity<String> rollback() {
        if (prepared) {
            System.out.println("Order Rolled Back");
            prepared = false;
        }
        return ResponseEntity.ok("Rolled back");
    }
}
üìå 3. PaymentService (similar to OrderService)
@RestController
@RequestMapping("/payment")
public class PaymentController {

    private boolean prepared = false;

    @PostMapping("/prepare")
    public ResponseEntity<String> prepare() {
        prepared = true;
        System.out.println("Payment Prepared");
        return ResponseEntity.ok("OK");
    }

    @PostMapping("/commit")
    public ResponseEntity<String> commit() {
        if (prepared) {
            System.out.println("Payment Committed");
            prepared = false;
            return ResponseEntity.ok("Committed");
        }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Not prepared");
    }

    @PostMapping("/rollback")
    public ResponseEntity<String> rollback() {
        if (prepared) {
            System.out.println("Payment Rolled Back");
            prepared = false;
        }
        return ResponseEntity.ok("Rolled back");
    }
}

implement Rate limiter in ms
======================================

how to handle distributed transactions
---------------------------------------
üîπ Solutions / Patterns to Handle Distributed Transactions
1. Two-Phase Commit (2PC) (Classic)
Coordinator asks all participants: Can you commit? (prepare phase).
If all agree, sends commit (commit phase).
Guarantees ACID.

‚ùå Cons: Blocking, poor performance, single point of failure, not suitable for high-scale microservices.
‚úÖ Still used in relational DB clusters (XA, JTA in Java EE).

2. Saga Pattern (Most common in Microservices üöÄ)
Break transaction into a sequence of local transactions.
Each service does its own DB commit (no global lock).
If one step fails ‚Üí execute compensating transactions (undo).

Two types of Saga:
Choreography (Event-driven)
Services publish events after success.
Other services listen and continue.
Example: Order Service ‚Üí "Order Created" ‚Üí Payment Service ‚Üí "Payment Done" ‚Üí Inventory Service.
Simple, but can get messy with many services.

Orchestration
A central Saga orchestrator tells services what to do next.
Easier to manage flow.
Example: Orchestrator ‚Üí call Payment ‚Üí if success call Inventory ‚Üí else rollback Payment.

3. TCC (Try-Confirm/Cancel)

Each service provides 3 operations:
Try ‚Üí Reserve resources (but don‚Äôt commit fully).
Confirm ‚Üí Finalize reservation.
Cancel ‚Üí Rollback reservation.
Example: Booking system ‚Üí Try (lock seat), Confirm (issue ticket), Cancel (release seat).

‚úÖ Strong consistency.

‚ùå Hard to implement for every service.
4. Idempotency + Retries
Ensure operations can be retried safely without side effects.
Example: Payment service should not double-charge if the same message is processed twice.

Use unique transaction IDs.

5. Outbox Pattern
Service writes to its DB + an outbox table (with events).
A background process (or Debezium/CDC) publishes events reliably.
Ensures no message loss between DB + Kafka/RabbitMQ.

6. Eventual Consistency
Accept that data may be temporarily inconsistent, but will converge.
Users might see a "pending" state until all services finish.
üîπ Example: Order + Payment + Inventory
Order Service ‚Üí create order (status = PENDING).
Payment Service ‚Üí deduct money.

If fails ‚Üí publish rollback event ‚Üí Order Service marks FAILED.
Inventory Service ‚Üí reduce stock.
If fails ‚Üí publish rollback ‚Üí Payment refunds ‚Üí Order set FAILED.
If all success ‚Üí Order status = CONFIRMED.

üëâ This is a Saga with compensations.

üîπ Interview Takeaway
2PC ‚Üí strict ACID, but slow and rarely used in microservices.
Saga ‚Üí industry standard for microservices (Choreography / Orchestration).
TCC ‚Üí useful for resource reservation scenarios (travel, banking).
Outbox + Idempotency ‚Üí ensure reliable messaging.
Eventual Consistency ‚Üí tradeoff in distributed systems.

spring to spring boot migration
--------------------------------------
1. Analyze current application
Check: Spring version, dependencies, build tool (Maven/Gradle), web container (Tomcat/Jetty), configuration style (XML vs JavaConfig).
2. Upgrade build tool
3. Remove external container
4. Migrate configuration
5. Externalize properties
6. Leverage Auto-Configuration
7. Refactor Logging
8. Actuator & Monitoring

1. Does Spring Boot Manage Sessions Automatically?

Yes, if you use Spring Security (and don‚Äôt disable session management), it will:
Create a session after successful login.
Store authentication (username, roles, etc.) inside that session.
Send a JSESSIONID cookie to the client.
On subsequent requests, lookup the session and authenticate automatically.


how to ALC/NLC how to configure
--------------------------------------
Controls who can talk to whom at the network level (before requests even reach your app).
Examples:

Firewalls (on-premise or cloud).
Security groups (AWS, Azure, GCP).
Network ACLs (subnet-level rules).
Service Mesh (Istio, Linkerd) with mTLS and policies.

‚úÖ Configuration Examples:
AWS Security Group:
Allow port 8080 only from load balancer subnet.
Block all external access except HTTPS (443).
Kubernetes Network Policy (NLC in MS world):

YML changes

2. ALC ‚Äì Access Level Control
Examples:

Role-Based Access Control (RBAC) ‚Üí ADMIN, USER, GUEST.
Attribute-Based Access Control (ABAC) ‚Üí e.g., ‚Äúusers can only access their own data‚Äù.
OAuth2 scopes / API permissions.
Spring Security (RBAC ALC):

http.authorizeRequests()
    .antMatchers("/admin/**").hasRole("ADMIN")
    .antMatchers("/user/**").hasAnyRole("USER", "ADMIN")
    .anyRequest().authenticated();

Policy in API Gateway:
routes:
  - id: orders
  
NLC (Network Level Control) = Who can reach the service? Configured via firewall rules, Kubernetes NetworkPolicies, service mesh policies.
ALC (Access Level Control) = What can the authenticated user/service do? Configured via Spring Security, API Gateway, OAuth2 scopes, RBAC/ABAC.


============================
Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
 
Input: s = "abcdef" 
Output: 0
 
Input: s = "mississippi" 
Output: 0


You are given N chocolates, and you need to distribute them among some children based on the following conditions:
 
You can choose the number of children .
Each child must receive at least 2 chocolates.
No single child can receive all the chocolates.
All chocolates must be distributed evenly (i.e., no remainders).
Each child must receive whole chocolates (no fractional distribution).
Your task is to determine whether it is possible to distribute the chocolates fairly under the given conditions.
 
Input:
A positive integer N representing the total number of chocolates.
Output:
Print "Yes" if it is possible to distribute the chocolates fairly.
Print "No" if it is not possible to distribute the chocolates fairly.
Example:
N = 10
Output 1:
Yes
Explanation:
We can choose k = 5 (5 children).
Each child will get exactly 2 chocolates (10 chocolates / 5 children).
All conditions are satisfied:
Each child gets at least 2 chocolates.
No child receives all the chocolates.
The chocolates are distributed evenly.
Input 2:
ini
Copy code
N = 2
Output 2:
No
Explanation:
With 2 chocolates, we can only give them to one child, but the condition states that no one child can receive all the chocolates. Hence, it's not possible to distribute the chocolates according to the given rules


===============================
Future and CompitableFuture diffrence
------------------
Future<Integer> future = executor.submit(() -> {
    Thread.sleep(2000);
    return 42;
});

// blocking call
Integer result = future.get();  
// check if done
boolean isDone = future.isDone();

// cancel if needed
future.cancel(true);
‚ùå Limitations of Future
‚ùå No way to manually complete a Future.
‚ùå No way to chain multiple async tasks (no callbacks).
‚ùå get() is blocking ‚Äî no non-blocking mechanism.
‚ùå Can't react to completion without polling isDone() or calling get().

‚ö° 2. CompletableFuture (Java 8)
Package: java.util.concurrent
Introduced in: Java 8

‚úÖ Purpose
A more powerful class that:

Implements both Future and CompletionStage
Supports non-blocking, reactive, and declarative async programming
Allows manual completion
Allows chaining, combining, and exception handling

‚ú® Key Features
a) Manual completion
CompletableFuture<String> cf = new CompletableFuture<>();
// later
cf.complete("Done!");
System.out.println(cf.get());  /


Kafka, how to handle if producer is slower then cansumer and viceversa
============================================================

Case 1: Producer is Slower than Consumer
Problem

Consumer may quickly consume everything and then keep polling and finding nothing new.
This usually doesn‚Äôt cause system failure, but may cause:
Low consumer throughput
Empty polls ‚Üí unnecessary CPU usage
Rebalances if consumers keep polling with no data

‚úÖ Ways to Handle
1.
Use poll() efficiently with proper pollTimeout
Consumers should not spin too fast when there‚Äôs no data.
Use a reasonable poll timeout (e.g., 100‚Äì500 ms) so they wait a bit for new messages.
ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(500));

2Ô∏è‚É£ Scale down consumers or pause them

If you have too many consumers for a small producer, some may remain idle.
You can pause partitions for consumers if needed:
consumer.pause(consumer.assignment());
// resume later when producer catches up
consumer.resume(consumer.assignment());

3Ô∏è‚É£ Batch Processing / Time-based buffering
Consumers can buffer incoming data and process in batches or at intervals to avoid spinning too fast.
4Ô∏è‚É£ Elastic scaling
If using Kubernetes or auto-scaling groups, scale consumers down when producer load is low, and scale up when producer load increases.

üß† Case 2: Producer is Faster than Consumer
Problem

Lag builds up in the consumer group (check via Kafka offset lag metrics).
Kafka brokers store data longer ‚Üí potential disk pressure.
Consumers may fall far behind, increasing end-to-end latency.
If consumers are too slow, messages might expire based on retention.ms before they‚Äôre consumed.

1Ô∏è‚É£ Scale Out Consumers (Horizontal Scaling)
Add more consumer instances in the same consumer group to process partitions in parallel.
üëâ This is the most common solution.

‚ö†Ô∏è Number of consumers should not exceed number of partitions per topic (otherwise some consumers remain idle).
2Ô∏è‚É£ Optimize Consumer Processing

Reduce per-record processing time (e.g., move heavy DB writes to async, batch DB inserts).

Use bulk processing instead of processing messages one by one.

Tune max.poll.records to process larger batches per poll.

max.poll.records=500

3Ô∏è‚É£ Use Backpressure / Flow Control
If consumer cannot keep up, throttle producer:
At application level (e.g., producer sleeps or rate limits)
Or use Kafka‚Äôs acks and max.in.flight.requests.per.connection to naturally slow down producer under pressure.
You can monitor consumer lag metrics and apply dynamic throttling.

4Ô∏è‚É£ Increase Topic Partitions

More partitions ‚Üí more parallelism (consumers can be scaled horizontally more effectively).
But requires re-partitioning, so do it carefully.

5Ô∏è‚É£ Use Kafka Broker Retention Settings
If you expect temporary bursts, you can retain messages longer:
retention.ms=604800000   # 7 days


This gives consumers more time to catch up without data loss.
6Ô∏è‚É£ Consumer Pause & Resume
If processing is heavy:
Pause fetching new messages until the current batch is processed.
Resume afterward.

consumer.pause(consumer.assignment());
// process current batch
consumer.resume(consumer.assignment());
Prevents the consumer from getting overwhelmed with too many unprocessed messages in memory.
7Ô∏è‚É£ Use Multiple Consumer Groups (if needed)
For different processing pipelines (e.g., fast vs. slow consumers), use separate consumer groups to isolate processing.


how to optimization do for slow queries
=========================================
First step: understand why it's slow before optimizing.

‚úÖ Use EXPLAIN or EXPLAIN ANALYZE
In MySQL:
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

In PostgreSQL:
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;
You‚Äôll see details like:
Which indexes are used
Whether a full table scan is happening
Estimated vs actual row counts
Join algorithms used (nested loop / hash / merge)

üß† 2. Add or Improve Indexes
‚úÖ Common indexing tips:

Add indexes on columns used in WHERE, JOIN, GROUP BY, ORDER BY.
Use composite indexes for queries with multiple conditions, but order matters:

üß† 3. Rewrite the Query (Logic Optimization)
Examples:

Avoid SELECT * ‚Üí select only required columns
Replace IN with EXISTS or JOIN if it performs better
Avoid subqueries in WHERE when you can use JOIN or CTE
Use proper filtering early to reduce scanned rows

üß† 4. Denormalization / Materialized Views
üß† 5. Use Proper Pagination
6. Avoid N+1 Query Problems (App Level)
7. Tune Database Parameters
8. Partition Large Tables
9. Use Caching Layers

AWS S3 gives 403 what can be cuase
=========================================
Cause	                                                               Description	                     Check / Fix
Invalid credentials	Wrong,                                            expired, or missing access keys	Verify keys, test with aws s3 ls
Missing IAM permissions	                                              User/role lacks required actions	Check IAM policy (GetObject/PutObject)
Bucket policy denies	                                              Explicit deny overrides allow	    Check bucket policy
Block public access	Public URL                                        blocked by settings	            heck bucket/public access settings
Wrong bucket/key	                                                  Typos or non-existent resource	Double-check names (case-sensitive)
Cross-account issues	                                              Role trust or bucket policy misconfigured	Verify both accounts‚Äô policies
Pre-signed URL expired/invalid	U                                    RL expired or signature issue	Re-generate URL, check time
Region mismatch	SDK or                                              URL uses wrong region	Match bucket region
ACL/Object ownership	                                          Missing read permissions via ACL	Adjust object ACL or bucket owner controls